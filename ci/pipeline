#!/usr/bin/env amm

// Get a logging backend into classpath.
import $ivy.`org.slf4j:slf4j-simple:1.7.25`

import ammonite.ops._
import ammonite.ops.ImplicitWd._
import java.util.concurrent.TimeUnit
import scala.concurrent.duration._
import scala.util.control.NonFatal
import scala.util.Try

import $file.awsClient
import $file.dataDogClient
import $file.fileUtil
import $file.githubClient
import $file.provision
import $file.upgrade
import $file.utils

import utils.SemVer


implicit val SemVerRead: scopt.Read[SemVer] =
  scopt.Read.reads(SemVer(_))

val PACKAGE_DIR: Path = pwd / 'target / 'universal
val PACKAGE_DOCS_DIR: Path = pwd / 'target / "universal-docs"

/**
 * Compile Marathon and run unit and integration tests followed by scapegoat.
 *
 * @param logFileName Name of file which collects logs.
 */
@main
def compileAndTest(logFileName: String): Unit = utils.stage("Compile and Test") {

  def run(cmd: String *) = utils.withCleanUp {utils.runWithTimeout(60.minutes, logFileName)(cmd)}

  run("sbt", "clean", "test", "integration:test", "scapegoat")

  // Compile other projects.
  run("sbt", "benchmark/compile")
  run("sbt", "mesos-simulation/compile")
  run("sbt", "plugin-interface/compile")

  // Check system integration tests.
  // TODO: release 1.5 is not ready for flake8 yet!
  // checkSystemIntegrationTests(logFileName)
}

@main
def checkSystemIntegrationTests(logFileName: String): Unit = {
  def run(cmd: String *) = utils.runWithTimeout(60.minutes, logFileName)(cmd)
  run("flake8", "--count", "--max-line-length=120", "tests/system", "src/test/python")
}

/**
 * Compresses sandboxes and logs.
 *
 * @param logFileName Name of log file.
 */
@main
def zipLogs(logFileName: String = "ci.log"): Unit = {
  Try(%("tar", "-zcf", "sandboxes.tar.gz", "sandboxes"))
  Try(%("tar", "-zcf", s"$logFileName.tar.gz", "--remove-files", logFileName))
}

@main
/**
 * Upload Marathon tgz tarballs, its sha1 checksum and docs to S3.
 *
 * @param version The version to upload.
 * @param buildLocation subfolder location to upload tarball to. Example: "builds"
 * @return Artifact description if it was uploaded.
 */
def uploadTarballPackagesToS3(version: SemVer, buildLocation: String): Option[awsClient.Artifact] = utils.stage("Upload Tarball Packages") {
  import scala.collection.breakOut

  // Upload docs
  val docsPath = PACKAGE_DOCS_DIR / s"marathon-docs-$version.tgz"
  awsClient.upload(docsPath, awsClient.s3PathFor(buildLocation))

  // Upload Marathon
  PACKAGE_DIR.toIO.listFiles.filter(f => f.getName.endsWith(".tgz"))
    .headOption.flatMap(file => awsClient.archiveArtifact(Path(file), awsClient.s3PathFor(buildLocation)))
}

/**
 * Creates the tarball files of the Marathon runnable package with their
 * associated sha1 and the tarball of the documentation with the RAML definitions.
 *
 * @return version of build.
 */
@main
def createTarballPackages(): SemVer = utils.stage("Package Tarballs") {
  val result = %%('sbt, "universal:packageZipTarball", "universal-docs:packageZipTarball", "version")

  // Regex is for version:
  // starting with random chars, match $number$dot$number$dot$number followed by optional alpha numberic chars plus `-`
  // ending with random characters
  // we need to regex this string because we do have colored output in the `sbt version` command
  val VersionLineRegex = "^.*(\\d+\\.\\d+\\.\\d+[-A-Za-z\\d]+).*$".r
  // release version example v1.5.2
  val ReleaseVersionLineRegex = "^.*(\\d+\\.\\d+\\.\\d+).*$".r

  // Nothing is what it seems. This is a poor man's way to extract the version
  // from sbt's console output until we run our Ammonite scripts in sbt.
  val lastLine = result.out.lines.last
  val version = lastLine match {
    case VersionLineRegex(v) => v
    case ReleaseVersionLineRegex(v) => v
    case _ =>
        val commit = %%('git, "log", "--pretty=format:%h", "-n1").out.lines.last
        s"unknown version in commit $commit with version: $lastLine"
  }
  println(s"Built tarballs for Marathon $version.")
  SemVer(version)
}

/**
 * The pipeline target for GitHub pull request builds. It wraps other targets
 * and does some additional reporting to GitHub.
 */
def asPullRequest(run: => (SemVer, Option[awsClient.Artifact])): Unit = {
  val pullNumber: String = sys.env.getOrElse("CHANGE_ID", throw new IllegalArgumentException("No CHANGE_ID was defined."))
  val buildUrl: String = sys.env.getOrElse("BUILD_URL", throw new IllegalArgumentException("No BUILD_URL was defined."))
  val buildTag: String = sys.env.getOrElse("BUILD_TAG", "here")

  try {
    githubClient.reject(pullNumber, buildUrl, buildTag)
    val (_, maybeArtifact) = run
    githubClient.reportSuccess(pullNumber, buildUrl, buildTag, maybeArtifact)
  } catch {
    case NonFatal(e) =>
      githubClient.reportFailure(pullNumber, buildUrl, buildTag, e.getMessage())
      throw e
  }
}

/**
 * Update DC/OS repository and triggers build of update DC/OS image.
 *
 * @param version The newly built Marathon version.
 * @param artifactUrl Url for the saved Marathon artifact.
 * @param sha1 The sah1 checksum of the artifact.
 */
@main
def updateDcosImage(version: String, artifactUrl: String, sha1: String): Unit = utils.stage("Patch DC/OS Branch") {
  upgrade.updateMarathon(artifactUrl, sha1, s"Update Marathon to $version")
  upgrade.updateMarathonEE(artifactUrl, sha1, s"Update Marathon to $version")
}

/**
 * Provision the build host.
 */
def provisionHost(): Unit = utils.stage("Provision") {
  // Set port range for random port 0 allocation.
  %('sudo, "ci/set_port_range.sh")

  provision.killStaleTestProcesses()
  provision.installMesos()
}

//////////////////// MAIN TARGETS ////////////////////

/**
 * Run the main build pipeline.
 *
 * @return Version of Marathon build
 */
@main
def build(runTests: Boolean = true): SemVer = {
  if (runTests) {
    val logFileName = s"ci-${sys.env.getOrElse("BUILD_TAG", "run")}.log"
    try {
      compileAndTest(logFileName)
    } finally {
      zipLogs(logFileName)    // Try to archive ci and sandbox logs in any case
    }
  }

  createTarballPackages()
}

/**
  * Builds docker and linux native packages, then runs the tests in tests/package/test.sc
  */
def buildDockerAndLinuxPackages(): Unit = {
  utils.stage("Package Docker Image, Debian and RedHat Packages") {
    %('sbt, "docker:publishLocal", "packageLinux")
  }
}

def testDockerAndLinuxPackages(): Unit = {
  utils.stage("Testing Docker Image, Debian and RedHat Packages") {
    // create test-bed docker images and run the package tests
    val testPath = pwd/'tests/'package
    %('make, "test")(testPath)
  }
}

/**
 * Build target for master and potential release branches.
 */
@main
def master(): Unit = {
  provisionHost()

  val version = build()
  buildDockerAndLinuxPackages()
  testDockerAndLinuxPackages()

  // Uploads
  uploadTarballPackagesToS3(version, s"builds/$version")
}

/**
 * Build target for pull request builds.
 */
@main
def pr(): Unit = asPullRequest {
  provisionHost()
  val version = build()

  // Uploads
  val artifact = uploadTarballPackagesToS3(version, s"builds/$version")
  (version, artifact)
}

/**
 * Build target for our build loop.
 */
@main
def loop(): Unit = {
  val start = System.currentTimeMillis
  try {
    provisionHost()
    build()
    dataDogClient.reportCount(s"marathon.build.${utils.loopName}.success", 1)
  } catch {
    case _ => dataDogClient.reportCount(s"marathon.build.${utils.loopName}.failure", 1)
  } finally {
    dataDogClient.reportCount(s"marathon.build.${utils.loopName}.duration", ((System.currentTimeMillis - start) / 1000).toInt)
  }
}

/**
 * The main pipeline target for builds on Jenkins.
 *
 * @return Version and artifact description of Marathon build.
 */
@main
def jenkins(): Unit = {
  if(utils.isPullRequest) pr()
  else master()
}

sealed trait ReleaseTarget {
  val name: String
}

object ReleaseTarget {
  case object DockerTag extends ReleaseTarget {
    val name = "docker-tag"
  }
  case object DockerLatest extends ReleaseTarget {
    val name = "docker-latest"
  }
  case object LinuxPackages extends ReleaseTarget {
    val name = "linux-packages"
  }
  case object JARArtifact extends ReleaseTarget {
    val name = "jar-artifact"
  }
  case object S3Package extends ReleaseTarget {
    val name = "s3-package"
  }

  val all = Seq(DockerTag, DockerLatest, S3Package, LinuxPackages, JARArtifact)
}

/**
 * Executes the Community Release which includes:
 *  1. tarball with version details
 *  2. release of docker with that version
 *  3. git tag of version (pushed to server)
 * @param requestVersion The version attempting to be released v1.4.6
 * @param gitSha The git commit sha.  This can be shorthand (ex. 0e1)
 * @param latest Boolean to indicat if the Docker latest should be updated to this version.
 * @return Version and artifact description of Marathon build.
 */
@main
def release(args: String*): Unit = {
  case class Config(
    version: SemVer = SemVer.empty,
    targets: List[ReleaseTarget] = Nil,
    runTests: Boolean = true,
    checkout: Option[String] = None)

  val parser = new scopt.OptionParser[Config]("scopt") {
    head("pipeline release")
    opt[SemVer]("version").required.action { (v, c) =>
      c.copy(version = v)
    }
    opt[Boolean]("run-tests").required.action { (runTests, c) =>
      c.copy(runTests = runTests)
    }
    opt[String]("checkout").action {
      case ("", c) => c.copy(checkout = None)
      case (checkout, c) => c.copy(checkout = Some(checkout))
    }
    arg[String]("targets...").unbounded.optional.action { (target, c) =>
      ReleaseTarget.all.find(_.name == target) match {
        case Some(rt) => c.copy(targets = rt :: c.targets)
        case None =>
          throw new RuntimeException(s"${target} is not a known release target; valid options are:\n* ${ReleaseTarget.all.map(_.name).mkString("\n* ")}")
      }
    }
  }

  val config = parser.parse(args, Config()).getOrElse {
    sys.exit(1)
    ???
  }

  config.checkout.foreach { gitSha =>
    %('git, "checkout", gitSha)
  }

  %('git, "tag",
    "-a", config.version.toTagString,
    "-m", config.version.toTagString)
  val builtVersion = build(config.runTests)
  assert(builtVersion == config.version,
    "Specified version did not match built version! ${builtVersion} != ${config.version}")
  println(s"Built version ${builtVersion}; releasing")

  buildDockerAndLinuxPackages()
  if (config.runTests)
    testDockerAndLinuxPackages()

  config.targets.distinct.foreach {
    case ReleaseTarget.LinuxPackages =>
      uploadLinuxPackagesToRepos(s"v{config.version}")
    case ReleaseTarget.S3Package =>
      uploadTarballPackagesToS3(config.version, s"releases/${config.version}")
    case ReleaseTarget.DockerTag =>
      %('docker, "push", s"mesosphere/marathon:${config.version.toTagString}")
    case ReleaseTarget.DockerLatest =>
      %('docker, "tag", s"mesosphere/marathon:${config.version.toTagString}", "mesosphere/marathon:latest")
      %('docker, "push", "mesosphere/marathon:latest")
    case ReleaseTarget.JARArtifact =>
      // publishing to the nexus repository.  This artifact is used by metronome.
      %('sbt, "publish")
  }

  // TODO: git push fails currently b/c jenkins isn't authorized to push to GH
  // %('git, "push", "--tags")

  // TODO: Publish swagger files.
}

/**
  * Given tagName v1.5.1, and rev DEADBEEF, we would assert that v1.5.0 is a direct ancestor of rev DEADBEEF
  * this ensures that a v1.5.1 release can NOT happen on a branch that had a v1.6.0 release.
  *
  * Also, we assert that rev contains new commits since the last release. If the proposal is to tag v1.5.1 with same
  * revision as v1.5.0, then we fail, saying that there v1.5.0 points to the commit porposed for v1.5.1
  *
  * @param tagName The tag name / version we are going to tag. eg v1.5.1
  * @param gitSha The commit sha / rev that will be tagged.
  */
def assertPriorVersionIsAncestor(tagName: String, gitSha: String): Unit = {
  utils.priorPatchVersion(tagName).foreach { prior =>
    val revs = %%("git", "rev-list", "--format=oneline", s"${gitSha}..${prior}").out.string
    if(revs.trim.nonEmpty) {
      println(s"Error! ${prior} is not a direct ancestor of proposed commit ${gitSha} for ${tagName}!")
      sys.exit(1)
    }

    val commitsSinceLast = %%("git", "rev-list", "--format=oneline", s"${prior}..${gitSha}").out.string
    if(commitsSinceLast.trim.isEmpty) {
      println(s"Error! ${prior} points to proposed commit ${gitSha} for ${tagName}!")
      sys.exit(1)
    }
  }
}

def uploadLinuxPackagesToRepos(tagName: String): Unit = {
  val pkgserverUser = sys.env.getOrElse("PKG_SSH_USER", {
    throw new IllegalStateException("PKG_SSH_USER environment variable must be set")
  })
  val pkgserverHost = sys.env.getOrElse("PKG_SSH_HOST", {
    throw new IllegalStateException("PKG_SSH_HOST environment variable must be set")
  })

  // Note - the key is expected to be provided via an SSH agent
  utils.printStageTitle(s"Uploading native packages")
  %("rsync", "-avz",
    (pwd / 'target / 'packages) + "/",
    s"${pkgserverUser}@${pkgserverHost}:repo/incoming/marathon-${tagName}/")

  val pkgType = if (tagName.toLowerCase contains "rc")
    "-testing"
  else
    ""

  val mappings = Seq(
    "systemd" -> s"debian/jessie${pkgType}",
    "systemd" -> s"ubuntu/yakkety${pkgType}",
    "systemd" -> s"ubuntu/xenial${pkgType}",
    "systemd" -> s"ubuntu/wily${pkgType}",
    "systemd" -> s"ubuntu/vivid${pkgType}",
    "upstart" -> s"ubuntu/trusty${pkgType}",
    "upstart" -> s"ubuntu/precise${pkgType}",
    "systemv" -> s"el${pkgType}/6",
    "systemd" -> s"el${pkgType}/7")

  val copyCommands = mappings.map { case (packageType, path) =>
    s"cp $$HOME/repo/incoming/marathon-${tagName}/${packageType}-marathon* " +
    s"$$HOME/repo/incoming/${path}/"
  }.mkString(";")

  utils.printStageTitle("Distributing packages to distros")
  %("ssh", s"${pkgserverUser}@${pkgserverHost}", "bash",
    "-e", "-x", "-c",
    utils.escapeCmdArg(List(
      copyCommands,
      s"rm -rf $$HOME/repo/incoming/marathon-${tagName}").mkString("\n")))

  utils.printStageTitle("All done")
}
