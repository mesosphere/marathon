---
title: Stateful Applications Using External Persistent Volumes
---

# Stateful Applications Using External Persistent Volumes

<div class="alert alert-danger" role="alert">
  <span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span> Adapted in Marathon Version 1.0 <br/>
  The Persistent Storage functionality is considered beta, so use this feature at your own risk. We might add, change, or delete any functionality described in this document.
</div>

Marathon applications normally lose their state when they terminate and are relaunched. In some contexts, for instance, if your application uses MySQL, youâ€™ll want your application to preserve its state. You can use an external storage service, such as Amazon's Elastic Block Store (EBS), to create a persistent volume that follows your application instance.

Using an external storage service allows your apps to be more fault-tolerant. If a host fails, Marathon reschedules it on another host, along with its associated data, without user intervention.

# Specifying an External Volume

If you are running Marathon on DCOS, add the following to the `genconf/config.yml` file you use during DCOS installation. [Learn more](https://docs.mesosphere.com/concepts/installing/installing-enterprise-edition/configuration-parameters/).

- `rexray_config_method: file`

- `rexray_config_filename: /path/to/rexray.yaml`

## Scaling your App

Apps that use external volumes should only be scaled to a single instance.

If you scale your app down to 0 instances, the volume is unattached from the agent where it was mounted, but it is not deleted. If you scale your app up again, the data that had been associated with it will still be available.

## Create an Application with External Volumes

### Using a Mesos Container

You specify an external volume in the app definition of your Marathon app. [Learn more about Marathon application definitions](application-basics.html).

```json
{
  "id": "hello",
  "instances": 1,
  "cpus": 0.1,
  "mem": 32,
  "cmd": "/usr/bin/tail -f /dev/null",
  "container": {
    "type": "MESOS",
    "volumes": [
      {
        "containerPath": "/tmp/test-rexray-volume",
        "external": {
          "size": 100,
          "name": "my-test-vol",
          "provider": "dvdi",
          "options": { "dvdi/driver": "rexray" }
          },
        "mode": "RW"
      }
    ]
  },
  "upgradeStrategy": {
    "minimumHealthCapacity": 0,
    "maximumOverCapacity": 0
  }
}
```

In the app definition above:

- `containerPath` specifies where the volume is mounted inside the container. This path is configurable, but defaults to `data/`. See [the REX-Ray documentation on data directories](https://rexray.readthedocs.org/en/v0.3.2/user-guide/config/#data-directories) for more information.

- The `external.driver["dvdi/driver"]` option specifies which Docker volume driver to use for storage. If you are running Marathon on DCOS, this value should always be `rexray`. [Learn more about REX-Ray](https://rexray.readthedocs.org/en/v0.3.2/user-guide/schedulers/).

- You can specify additional options with `container.volumes[x].external.options[optionName]`.

- `name` is the name by which your volume driver looks up your volume. When your task is staged on an agent, the volume driver queries the storage service for a volume with this name. If one does not exist, it's created. Otherwise, the existing volume is re-used. **Note:** Implicit volume creation only works when using volumes with a Mesos container.

- Create multiple volumes by adding additional items in the `container.volumes` array.

- Volume parameters cannot be changed after you create the application.

- **Note:** Marathon will not launch apps with external volumes if  `upgradeStrategy.minimusHealthCapacity` is less than 0.5, or if `upgradeStrategy.maximumOverCapacity` does not equal 0.

### Using a Docker Container

Below is a sample app definition that uses a Docker container and specifies an external volume:

```json
{
  "id": "/test-docker",
  "instances": 1,
  "cpus": 0.1,
  "mem": 32,
  "cmd": "/usr/bin/tail -f /dev/null",
  "container": {
    "type": "DOCKER",
    "docker": {
      "image": "alpine:3.1",
      "network": "HOST",
      "forcePullImage": true
    },
    "volumes": [
      {
        "containerPath": "/data/test-rexray-volume",
        "external": {
          "size": 100,
          "name": "my-test-vol",
          "provider": "dvdi",
          "options": { "dvdi/driver": "rexray" }
        },
        "mode": "RW"
      }
    ]
  },
  "upgradeStrategy": {
    "minimumHealthCapacity": 0,
    "maximumOverCapacity": 0
  }
}
```

For more information, refer to the [REX-Ray documentation](https://rexray.readthedocs.org/en/v0.3.2/user-guide/schedulers/#docker-containerizer-with-marathon).

## Potential Pitfalls

- You can only assign one task per volume. Your storage provider may other particular limitations.

- The volumes you create are not automatically cleaned up. If you you delete your cluster, go to your storage provider and delete the volumes you no longer need. If you using EBS, find them by searching by the `container.volume.external.name` that you set in your Marathon app definition. This name corresponds to an EBS volume `Name` tag.

- Volumes are not isolated from other clusters. Choose a unique volume name to avoid conflicts.

- Docker apps do not support external volumes on DCOS installations running Docker older than 1.8. Currently, this means that DCOS Community Edition users cannot create Docker apps with external volumes.

For more information, see the [Apache Mesos documentation on persistent volumes](http://mesos.apache.org/documentation/latest/persistent-volume/).
